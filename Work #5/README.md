# Обработка изображений средствами CUDA


Как Вы уже знаете из курса информатики, любое растровое изображение можно предстваить как двумерный массив точек (пикселей). В свою очередь, пиксели на изображении могут кодироваться по-разному. В самом простом случае (будем его называть 8UC1) мы будем иметь дело с 8-битным изображением в 1 канал. Такой пиксель обычно представяет 1 из 256 оттенков серого и занимает 1 байт (8 бит). Цветные изображения чаще всего кодируются 3 каналами - R,G,B. 

Такое разеление выбрано не случайно, и считается, что это минимальное необходимое количество каналов, чтобы в большой (но не полной) мере покрыть видимое человеком излучение света. В этом случае, мы будем говорить, что 1 пиксель занимает 3 байта и может кодировать 256*256*256 различных цветов.

Бывают и различные производные форматы, необходимые для вычислений, например, 32UC1 (1 канал размера 4 байта, uint). 32FC1 (1 канал float, 4 байта), и даже 32FC4.

Сегодгя мы познакомимся с тем, как на практике применить полученные знания о CUDA для обработки растровых изображений.

Для начала работы, нам потребуется тестовая картинка (желательно большого размера), и библиотека для чтения и сохранения изображений - OpenCV.

На самом деле OpenCV - это самый мощный в мире инструемент для работы с изображениями. Там есть тысячи методов и алгоритов обработки, часть из которых оптимизирована для выполнения на CUDA. Но наша задача разобраться самим, как это работает, а не просто взять готовую библиотеку. 

``` C
#include <stdio.h>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <random>
#include <cstdlib>
#include <cstdio>
#include <chrono>

using namespace cv;

int main(){
	// Читаем изображение
	Mat color_img = imread("test.jpg", IMREAD_COLOR);
	
	// Получаем его ширину и высоту
	int cols = color_img.cols;
	int rows = color_img.rows;	
	std::cout << cols << " x " << rows << std::endl;
	
	// Сохраняем изображение
    imwrite("test.png", color_img);
	
    return 0;
}
```

В этом блоке кода мы прочитали изображение, получили его размеры и сохранили в другом формате сжатия.

Стандартной командной строкой собрать приложение не получится. Дело в том, что OpenCV не поставляется по-умолчанию с компиляторами MSVC, GCC или NVCC. Библиотеку придётся скачать и установить. 

О том, как поставить OpenCV на Windows и подружить её с проектом Visual Studio можно почитать тут: https://www.geeksforgeeks.org/opencv-c-windows-setup-using-visual-studio-2019/

На Google-Colab Linux у нас уже она предустановлена, и чтобы её использовать, необходимо прописать пути к .h и .lib файлам. Команда `pkg-config --cflags --libs opencv4` сделает это за нас.
Таким образом, команда будет выглядеть вот так:

!nvcc cv_cuda.cu -o test `pkg-config --cflags --libs opencv4`


Соберите, запустите, убедитесь, что все работает.

Создание нового изображения.
Для работы также потреубется создать пустой холст, куда мы будем записывать результат:
``` CUDA
	// Используем для этого формат 8UC1 (градации серого)
	Mat gray_img = Mat::zeros(rows, cols,CV_8UC1);
``` 
А также получим указатели на расположение в RAM этих изображений. 

``` CUDA
	// Берем указатели на данные из изображения
	unsigned char* p_clr = color_img.ptr<unsigned char>();
	unsigned char* p_gray = gray_img.ptr<unsigned char>();
```

Дальше всю обработку мы будем делать через эти указатели. В памяти последовательно идут все строки, в каждой строке - все пиксли, в каждом пикселе - каналы.

Чтобы найти G канал пикселя с координатами X и Y, на изображении, размерностью Width и Height, необходимо обратится к памяти по следующему смещению: 
``` idx = Y * Width * 3 + 1 ```

Задание: Определите смещение для форматов 32FC1 и 8UC4

И рассмотрим самую простую обработку - обесцвечивание изображения. Для этого формируем значение канала ``` Gray = (Red + Green + Blue) / 3 ```. Делаем все это в 2х вложенных циклах, чтобы захваить все точки на изображении.

``` CUDA
	// Проходим циклом по Ширине и Высоте
	for (int x = 0; x < color_img.cols; x++){
		for (int y = 0; y < color_img.rows; y++){
			// Определяем индекс пикселя по такой формуле
			int idx = y * color_img.cols + x;
			
			// считаем средний цвет как сумму по каналам (B + G + R) / 3
			int sum = (p_clr[idx*3+0]+p_clr[idx*3+1]+p_clr[idx*3+2]) / 3;
			
			// Записываем в реузльтирующий
			p_gray[idx] =  sum;
		}
	}
```

Задание: Самостоятельно определите время выполения кода от момента начала цикла до его завершения. 

Задание: Найдите способ, как у изображения в градациях серого увеличить яркость на несколько единиц.

Теперь посмотрим, что необходимо добавить, чтобы реализовать задачу на CUDA.

Начнём с описания функции kernel. Я просто представлю весь её код. Найдите различия этой функции и тела циклов выше. Дайте объяснения написанному здесь дополнительному коду

``` CUDA
__global__ void RGB2GRAY_GPU(uchar *gp_clr, uchar *gp_gray, int rows, int cols) {
    // Получаем координаты на основании ID блока и треда
	int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
	
	// Определяем индекс пикселя по такой формуле
	int idx = y * cols + x;
	
	// Проверяем выходы за границу
    if (x > cols || y > rows)
        return;
	
	// Считаем сумму
	int sum = (gp_clr[idx*3+0]+gp_clr[idx*3+1]+gp_clr[idx*3+2]) / 3;
	
	// Записываем в реузльтирующий
	gp_gray[idx] =  sum;
    return;
} 
```

И теперь к вызову этой функции. У нас уже есть изображение в CPURAM. Его нужно скопировать в GPURAM. Для этого объявим указатели на видеопамять, выделим там нужное количество байт, и скопируем туда цветкую картинку. 

``` CUDA
	unsigned char *gp_clr;
    unsigned char *gp_gray;
	
	cudaMalloc(&gp_clr, sizeof(unsigned char) * rows * cols * 3);
    cudaMalloc(&gp_gray, sizeof(unsigned char) * rows * cols);
	

    cudaMemcpy(gp_clr, p_clr, sizeof(unsigned char) * rows * cols * 3, cudaMemcpyHostToDevice);
```

Также после вызова kernel необходимо скопировать память черно-белого изображения:

``` cuda
cudaMemcpy(p_gray, gp_gray, sizeof(unsigned char) * rows * cols, cudaMemcpyDeviceToHost);
```

И осталось только правильно вызвать kernel. С одной стороны - мы можем передать туда картинку как одномерный массив и обращаться сразу к нужному индексу, с другой - когда есть удобное средство для передачи координат (dim3), почему бы им не воспользоваться?

``` CUDA
	int THREAD_DIM = 0;
	dim3 gridSize (ceil(cols / (float)THREAD_DIM), ceil(rows / (float)THREAD_DIM));
    dim3 blockSize (THREAD_DIM, THREAD_DIM);

	RGB2GRAY_GPU<<< gridSize, blockSize>>>(gp_clr, gp_gray, rows, cols);
	
```

Задание: самостоятельно определите (аналитически или экспериментально) максимальное возможное значение THREAD_DIM, при котором kernel работает без ошибок.

Вот и весь код для того, чтобы цветное изображение привести к градациям серого. Оцените время работы алгоритма на CPU и на GPU и сделайте выводы о целесообразности применения GPU.

Самостоятельная работа

До тех пор, пока внутри kernel будет находится алгоритм, сложность которого ``` O(1) ```, ни о каком выигрыше говорить нет смысла. Давайте модифицируем программу таким образом, чтобы она еще делала размытие изображения, произвольным окном. Под размытием будем считать среднее арифметическое соседних пикселей 9, 25, 49 и т.д. соседних пикселей. В этом случае мы выходим на сложность ``` O(N^2) ``` и начинают появлятся первые выигрыши во времени. 

Модифицируйте kernel таким образом, чтобы он принимал на вход пользовательский фильтр произвольного размера.
